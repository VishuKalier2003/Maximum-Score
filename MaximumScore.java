/* You are given two sorted arrays of distinct integers nums1 and nums2...
A valid path is defined as follows:
* Choose array nums1 or nums2 to traverse (from index-0)...
* Traverse the current array from left to right...
* If you are reading any value that is present in nums1 and nums2 you are allowed to change your path to the other array... (Only one repeated value is considered in the valid path)...
* The score is defined as the sum of uniques values in a valid path...
Return the maximum score you can obtain of all possible valid paths...
*/
import java.util.*;
public class MaximumScore
{
    public int MaxSum(int nums1[], int nums2[])
    {
        Vector<Integer> vec1 = new Vector<Integer>();   // Vector defined...
        Vector<Integer> vec2 = new Vector<Integer>();   // Vector defined...
        int sum1 = 0, sum2 = 0;
        int i = 0, j = 0, index = 0;       // Variable declaration...
        while(i < nums1.length && j < nums2.length)    // While the end of loops is not reached...
        {
            if(nums1[i] != nums2[j])     // Evaluating when the two numbers are not same...
            {
                sum1 = sum1 + nums1[i];      // Sum of first list...
                sum2 = sum2 + nums2[j];      // Sum of second list...
            }
            if(nums1[i] == nums2[j])
            {
                vec1.add(index, sum1);    // Adding the sum to vector...
                vec2.add(index, sum2);    // Adding the sum to vector...
                sum1 = 0;     // Resetting values...
                sum2 = 0;     // Resetting values...
                i++;
                j++;
            }
            else if(nums1[i] < nums2[j])
                i++;      // Otherwise increment i...
            else if(nums1[i] > nums2[j])
                j++;       // Otherwise increment j...
        }
        System.out.println(vec1);
        System.out.println(vec2);
        int output = 0;
        for(int k = 0; k < vec1.size(); k++)
        {
            if(vec1.get(k) >= vec2.get(k))
                output = output + vec1.get(k);    // Storing the sum as per maximum...
            else 
                output = output + vec2.get(k);    // Storing the sum as per maximum...
        }
        return output;
    }
    public static void main(String[] args)
    {
        Scanner sc = new Scanner(System.in);
        int x;
        System.out.print("Enter length of first array : ");
        x = sc.nextInt();
        int arr1[] = new int[x];
        for(int i = 0; i < arr1.length; i++)
        {
            System.out.print("Enter data : ");
            arr1[i] = sc.nextInt();
        }
        System.out.print("Enter length of second array : ");
        x = sc.nextInt();
        int arr2[] = new int[x];
        for(int i = 0; i < arr2.length; i++)
        {
            System.out.print("Enter data : ");
            arr2[i] = sc.nextInt();
        }
        MaximumScore maximumscore = new MaximumScore();    // Object creation...
        x = maximumscore.MaxSum(arr1, arr2);          // Function calling...
        sc.close();
    }
}


// Time Complexity  - O(n) time...
// Space Complexity - O(k) space...

/* DEDUCTIONS :-
 * 1. We can first partition arrays on the basis of bridge numbers, which are numbers present in both arrays...
 * 2. Then we can greedily evaluate the maximum sum among the two arrays provided...
 */